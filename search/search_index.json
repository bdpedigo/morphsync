{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MorphSync","text":""},{"location":"#morphsync","title":"MorphSync","text":"<p>MorphSync is a Python library for working with multi-layered morphological data. It provides a unified framework for managing and synchronizing different representations of morphological data such as meshes, point clouds, graphs, and tabular data.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Multi-layer data management: Handle meshes, point clouds, graphs, and tables in a unified framework</li> <li>Linking: Create and manage mappings between different data layers</li> <li>Link-based operations: Apply masks/selections or features from one data layer to another</li> <li>Transitivity: Easily apply transitive mappings across multiple layers</li> <li>Lightweight: Intentionally light on algorithms, use your own tools but stop worrying about mappings</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from morphsync import MorphSync\n\n# Create a new morphology container\nmorphology = MorphSync(name=12345678)\n\nmesh_data # object with vertices and faces\npoint_data # dataframe of points with optional features\ngraph_data # object with nodes and edges, either with optional features\n\n# Add different layers\nmorphology.add_mesh(\"mesh\", mesh_data)\nmorphology.add_points(\"synapses\",\n    point_data, \n    spatial_columns=[\"x\", \"y\", \"z\"],\n)\nmorphology.add_graph(\"skeleton\",\n    graph_data,\n    spatial_columns=[\"x\", \"y\", \"z\"],\n    relation_columns=[\"source\", \"target\"],\n)\n\nsynapse_to_mesh_mapping # series mapping synapse indices to mesh indices\nmesh_to_skeleton_mapping # series mapping mesh indices to skeleton indices\n\n# Create mappings between layers\nmorphology.add_link(\"synapses\", \"mesh\", mapping=synapse_to_mesh_mapping)\nmorphology.add_link(\"mesh\", \"skeleton\", mapping=mesh_to_skeleton_mapping)\n\n# Select all aspects of the morphology that map to the skeleton's axon labeling\n# Note that transitive mapping (synapses &lt;-&gt; mesh &lt;-&gt; skeleton) works here!\nmapping = morphology.query_nodes(\"skeleton\", \"compartment == 'axon'\")\n\n# Add a column to synapses which indicates the local skeleton radius\nmorphology.assign_from_mapping(\"synapses\", \"skeleton\", [\"radius\"])\n</code></pre>"},{"location":"#core-concepts","title":"Core Concepts","text":""},{"location":"#layers","title":"Layers","text":"<p>MorphSync organizes data into layers, where each layer represents a different aspect of morphological data:</p> <ul> <li>Table: Tabular data without a spatial component</li> <li>Points: Point clouds such as annotations</li> <li>Graph: Network structures like skeletons or connectivity graphs</li> <li>Mesh: 3D surface representations with vertices and faces</li> </ul> <p>Note that it's possible to have multiple layers of the same type (e.g., multiple skeleton layers).</p>"},{"location":"#links","title":"Links","text":"<p>Links define relationships and mappings between layers. They enable you to:</p> <ul> <li>Use one layer to query or filter another layer</li> <li>Find features from one layer based on mappings; for instance, finding the radius of skeleton nodes that synapses map to</li> <li>Perform transitive mappings across multiple layers</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install morphsync\n</code></pre> <p>or, to add to a <code>uv</code> managed project or environment:</p> <pre><code>uv add morphsync\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#morphsync.MorphSync","title":"<code>morphsync.MorphSync</code>","text":"<p>Methods:</p> Name Description <code>__repr__</code> <p>Return a string representation of the MorphSync.</p> <code>add_graph</code> <p>Add a graph layer to the MorphSync.</p> <code>add_layer</code> <p>Add a layer of the specified type to the MorphSync.</p> <code>add_link</code> <p>Add a mapping link between two layers.</p> <code>add_mesh</code> <p>Add a mesh layer to the MorphSync.</p> <code>add_points</code> <p>Add a points layer to the MorphSync.</p> <code>add_table</code> <p>Add a table layer to the MorphSync.</p> <code>apply_mask</code> <p>Create a new MorphSync with a masked version of the specified layer.</p> <code>apply_mask_by_node_index</code> <p>Create a new MorphSync with a layer subset by node index.</p> <code>assign_from_mapping</code> <p>Assign values from the target layer to the source layer based on mapping.</p> <code>drop_layer</code> <p>Remove a layer from the MorphSync.</p> <code>get_layer</code> <p>Get a layer by name.</p> <code>get_link</code> <p>Get the mapping DataFrame between two layers.</p> <code>get_link_as_layer</code> <p>Create a Graph layer representing the mapping between two layers.</p> <code>get_link_path</code> <p>Find the shortest path of mappings between two layers.</p> <code>get_mapped_nodes</code> <p>Get features from the target layer for nodes mapped from the source layer.</p> <code>get_mapping</code> <p>Find mappings from source to target layers using the entire link graph.</p> <code>get_mapping_paths</code> <p>Find mappings from source to target layers using the entire link graph, and</p> <code>get_masking</code> <p>Get unique target indices that map to any of the specified source indices.</p> <code>get_params</code> <p>Get the parameters used to initialize this MorphSync container.</p> <code>has_layer</code> <p>Check if a layer with the given name exists.</p> <code>query_nodes</code> <p>Create a new MorphSync by querying nodes in a specific layer.</p> <p>Attributes:</p> Name Type Description <code>layer_names</code> <code>list[str]</code> <p>List of all layer names in the container.</p> <code>layer_types</code> <code>dict</code> <p>Dictionary mapping layer names to their class types.</p> <code>link_graph</code> <code>DiGraph</code> <p>NetworkX graph representing the connectivity between layers.</p>"},{"location":"api/#morphsync.MorphSync.layer_names","title":"<code>layer_names</code>  <code>property</code>","text":"<p>List of all layer names in the container.</p>"},{"location":"api/#morphsync.MorphSync.layer_types","title":"<code>layer_types</code>  <code>property</code>","text":"<p>Dictionary mapping layer names to their class types.</p>"},{"location":"api/#morphsync.MorphSync.link_graph","title":"<code>link_graph</code>  <code>property</code>","text":"<p>NetworkX graph representing the connectivity between layers.</p> <p>Returns:</p> Type Description <code>DiGraph</code> <p>Graph where nodes are layer names and edges represent mappings.</p>"},{"location":"api/#morphsync.MorphSync.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the MorphSync.</p>"},{"location":"api/#morphsync.MorphSync.add_graph","title":"<code>add_graph(name, graph, copy=True, **kwargs)</code>","text":"<p>Add a graph layer to the MorphSync.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new graph layer.</p> required <code>graph</code> <p>Graph data - either an object with 'vertices' and 'edges' attributes or a tuple of (vertices, edges).</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the input data.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to the Graph constructor.</p> <code>{}</code>"},{"location":"api/#morphsync.MorphSync.add_layer","title":"<code>add_layer(name, data, layer_type, copy=True, **kwargs)</code>","text":"<p>Add a layer of the specified type to the MorphSync.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new layer.</p> required <code>data</code> <code>Any</code> <p>Data for the layer, format depends on layer_type.</p> required <code>layer_type</code> <code>str</code> <p>Type of layer to create. Must be one of 'mesh', 'points', 'graph', or 'table'.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the input data.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to the layer constructor.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If layer_type is not one of the supported types.</p>"},{"location":"api/#morphsync.MorphSync.add_link","title":"<code>add_link(source, target, mapping='closest')</code>","text":"<p>Add a mapping link between two layers.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Name of the source layer.</p> required <code>target</code> <code>str</code> <p>Name of the target layer.</p> required <code>mapping</code> <code>Union[str, ndarray, DataFrame, Series, dict]</code> <p>Mapping specification. Options: - \"closest\": Map to nearest neighbors based on spatial coordinates - \"index\": Map by matching indices - np.ndarray: 1D array of target indices for each source element - pd.DataFrame: DataFrame with source and target columns - pd.Series: Series mapping source to target indices - dict: Dictionary mapping source to target indices</p> <code>'closest'</code>"},{"location":"api/#morphsync.MorphSync.add_mesh","title":"<code>add_mesh(name, mesh, copy=True, **kwargs)</code>","text":"<p>Add a mesh layer to the MorphSync.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new mesh layer.</p> required <code>mesh</code> <p>Mesh data - either an object with 'vertices' and 'faces' attributes or a tuple of (vertices, faces).</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the input data.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to the Mesh constructor.</p> <code>{}</code>"},{"location":"api/#morphsync.MorphSync.add_points","title":"<code>add_points(name, points, copy=True, **kwargs)</code>","text":"<p>Add a points layer to the MorphSync.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new points layer.</p> required <code>points</code> <p>Point coordinates as an array, DataFrame, or tuple containing points.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the input data.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to the Points constructor.</p> <code>{}</code>"},{"location":"api/#morphsync.MorphSync.add_table","title":"<code>add_table(name, table, copy=True, **kwargs)</code>","text":"<p>Add a table layer to the MorphSync.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new table layer.</p> required <code>table</code> <code>DataFrame</code> <p>DataFrame containing tabular data.</p> required <code>copy</code> <code>bool</code> <p>Whether to copy the input data.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments passed to the Table constructor.</p> <code>{}</code>"},{"location":"api/#morphsync.MorphSync.apply_mask","title":"<code>apply_mask(layer_name, mask)</code>","text":"<p>Create a new MorphSync with a masked version of the specified layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_name</code> <code>str</code> <p>Name of the layer to mask.</p> required <code>mask</code> <code>Union[ndarray, list]</code> <p>Boolean mask or indices to apply to the layer.</p> required <p>Returns:</p> Type Description <code>MorphSync</code> <p>New MorphSync with the masked layer and corresponding mappings to other layers.</p>"},{"location":"api/#morphsync.MorphSync.apply_mask_by_node_index","title":"<code>apply_mask_by_node_index(layer_name, new_index)</code>","text":"<p>Create a new MorphSync with a layer subset by node index.</p> <p>Parameters:</p> Name Type Description Default <code>layer_name</code> <code>str</code> <p>Name of the layer to subset.</p> required <code>new_index</code> <code>Union[Index, ndarray, list]</code> <p>Node indices to keep in the new layer.</p> required <p>Returns:</p> Type Description <code>MorphSync</code> <p>New MorphSync container with the subset layer and corresponding mappings to other layers.</p>"},{"location":"api/#morphsync.MorphSync.assign_from_mapping","title":"<code>assign_from_mapping(source, target, columns)</code>","text":"<p>Assign values from the target layer to the source layer based on mapping.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Name of the source layer that will receive the values.</p> required <code>target</code> <code>str</code> <p>Name of the target layer that provides the values.</p> required <code>columns</code> <code>Union[str, list, dict]</code> <p>Column specification: - str: Single column name to copy - list: List of column names to copy - dict: Mapping from source column names to target column names</p> required Notes <p>This modifies the source layer in place by adding/updating the specified columns.</p>"},{"location":"api/#morphsync.MorphSync.drop_layer","title":"<code>drop_layer(name)</code>","text":"<p>Remove a layer from the MorphSync.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to remove.</p> required"},{"location":"api/#morphsync.MorphSync.get_layer","title":"<code>get_layer(name)</code>","text":"<p>Get a layer by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to retrieve.</p> required <p>Returns:</p> Type Description <code>Layer</code> <p>The requested layer.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the layer does not exist.</p>"},{"location":"api/#morphsync.MorphSync.get_link","title":"<code>get_link(source, target)</code>","text":"<p>Get the mapping DataFrame between two layers.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Name of the source layer.</p> required <code>target</code> <code>str</code> <p>Name of the target layer.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the mapping between source and target layers.</p>"},{"location":"api/#morphsync.MorphSync.get_link_as_layer","title":"<code>get_link_as_layer(source, target)</code>","text":"<p>Create a Graph layer representing the mapping between two layers.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Name of the source layer.</p> required <code>target</code> <code>str</code> <p>Name of the target layer.</p> required <p>Returns:</p> Type Description <code>Graph</code> <p>Graph layer where edges connect mapped nodes between source and target layers. Source nodes come first in the node list, followed by target nodes.</p>"},{"location":"api/#morphsync.MorphSync.get_link_path","title":"<code>get_link_path(source, target)</code>","text":"<p>Find the shortest path of mappings between two layers.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Name of the source layer.</p> required <code>target</code> <code>str</code> <p>Name of the target layer.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of layer names representing the shortest path from source to target.</p>"},{"location":"api/#morphsync.MorphSync.get_mapped_nodes","title":"<code>get_mapped_nodes(source, target, source_index=None, replace_index=True, validate=None)</code>","text":"<p>Get features from the target layer for nodes mapped from the source layer.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Name of the source layer.</p> required <code>target</code> <code>str</code> <p>Name of the target layer.</p> required <code>source_index</code> <code>Optional[Union[ndarray, Index, Series]]</code> <p>Source indices to get mappings for. If None, uses all source indices.</p> <code>None</code> <code>replace_index</code> <code>bool</code> <p>Whether to replace the target indices with source indices in the result.</p> <code>True</code> <code>validate</code> <code>Optional[str]</code> <p>Whether to validate the mapping at each step. If specified, checks if each mapping between layers is of the specified type. Options are: - \"one_to_one\" or \"1:1\": check if join keys are unique in both source and target layers. - \"one_to_many\" or \"1:m\": check if join keys are unique in the source dataset. - \"many_to_one\" or \"m:1\": check if join keys are unique in the target dataset. - \"many_to_many\" or \"m:m\": allowed, but does not result in checks.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing target layer features for the mapped nodes.</p>"},{"location":"api/#morphsync.MorphSync.get_mapping","title":"<code>get_mapping(source, target, source_index=None, validate=None, dropna=False)</code>","text":"<p>Find mappings from source to target layers using the entire link graph.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Name of the source layer.</p> required <code>target</code> <code>str</code> <p>Name of the target layer.</p> required <code>source_index</code> <code>Optional[Union[ndarray, Index, Series]]</code> <p>Index of the source layer to map from. If None, uses all indices in the source layer.</p> <code>None</code> <code>validate</code> <code>Optional[str]</code> <p>Whether to validate the mapping at each step. If specified, checks if each mapping between layers is of the specified type. Options are: - \"one_to_one\" or \"1:1\": check if join keys are unique in both source and target layers. - \"one_to_many\" or \"1:m\": check if join keys are unique in the source dataset. - \"many_to_one\" or \"m:1\": check if join keys are unique in the target dataset. - \"many_to_many\" or \"m:m\": allowed, but does not result in checks.</p> <code>None</code> <code>dropna</code> <code>bool</code> <p>Whether to drop entries with null mappings. If False, returns NaN/pd.NA values for missing mappings.</p> <code>False</code> <p>Returns:</p> Type Description <code>Series</code> <p>Series with nodes in the source layer as the index and mapped nodes in the target layer as the values. Format depends on <code>dropna</code> parameter.</p> Notes <p>This function is a convenience wrapper around <code>get_mapping_paths</code> that returns just the final mapping as a Series. If you need to see the full mapping at each step, use <code>get_mapping_paths</code>.</p>"},{"location":"api/#morphsync.MorphSync.get_mapping_paths","title":"<code>get_mapping_paths(source, target, source_index=None, validate=None, dropna=False)</code>","text":"<p>Find mappings from source to target layers using the entire link graph, and describe the mapping at each step.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Name of the source layer.</p> required <code>target</code> <code>str</code> <p>Name of the target layer.</p> required <code>source_index</code> <code>Optional[Union[ndarray, Index]]</code> <p>Index of the source layer to map from. If None, uses all indices in the source layer.</p> <code>None</code> <code>validate</code> <code>Optional[str]</code> <p>Whether to validate the mapping at each step. If specified, checks if each mapping between layers is of the specified type. Options are: - \"one_to_one\" or \"1:1\": check if join keys are unique in both source and target layers. - \"one_to_many\" or \"1:m\": check if join keys are unique in the source dataset. - \"many_to_one\" or \"m:1\": check if join keys are unique in the target dataset. - \"many_to_many\" or \"m:m\": allowed, but does not result in checks.</p> <code>None</code> <code>dropna</code> <code>bool</code> <p>Whether to drop entries with null mappings. If False, returns NaN/pd.NA values for missing mappings.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Mapped indices in the target layer corresponding to the source_index in the source layer. Format depends on <code>dropna</code> parameter.</p>"},{"location":"api/#morphsync.MorphSync.get_masking","title":"<code>get_masking(source, target, source_index=None)</code>","text":"<p>Get unique target indices that map to any of the specified source indices.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Name of the source layer.</p> required <code>target</code> <code>str</code> <p>Name of the target layer.</p> required <code>source_index</code> <code>Optional[Union[ndarray, Index, Series]]</code> <p>Source indices to find mappings for. If None, uses all source indices.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of unique target indices that map to the source indices.</p>"},{"location":"api/#morphsync.MorphSync.get_params","title":"<code>get_params()</code>","text":"<p>Get the parameters used to initialize this MorphSync container.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing initialization parameters.</p>"},{"location":"api/#morphsync.MorphSync.has_layer","title":"<code>has_layer(name)</code>","text":"<p>Check if a layer with the given name exists.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the layer to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the layer exists, False otherwise.</p>"},{"location":"api/#morphsync.MorphSync.query_nodes","title":"<code>query_nodes(layer_name, query_str)</code>","text":"<p>Create a new MorphSync by querying nodes in a specific layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_name</code> <code>str</code> <p>Name of the layer to query.</p> required <code>query_str</code> <code>str</code> <p>Query string to pass to pandas DataFrame.query() method.</p> required <p>Returns:</p> Type Description <code>MorphSync</code> <p>New MorphSync container with the queried layer and corresponding mappings to other layers.</p>"},{"location":"api/#layers","title":"Layers","text":""},{"location":"api/#morphsync.Layer","title":"<code>morphsync.Layer</code>","text":"<p>Methods:</p> Name Description <code>get_params</code> <p>Get the parameters used to initialize this layer.</p> <code>mask_by_node_index</code> <p>Create a new layer containing only the specified nodes and their facets.</p> <code>mask_nodes</code> <p>Mask the nodes DataFrame and return a new layer with the</p> <code>query_nodes</code> <p>Query the nodes DataFrame and return a new layer with the</p> <p>Attributes:</p> Name Type Description <code>edge_index</code> <code>Index</code> <p>Index of the edges. Alias for facets_index.</p> <code>facets_index</code> <code>Index</code> <p>Index of the facets DataFrame.</p> <code>facets_positional</code> <code>ndarray</code> <p>Array of the facets in positional indexing, such that 0 corresponds to the</p> <code>layer_type</code> <code>str</code> <p>String identifier of the layer type (e.g., 'mesh', 'points', 'graph').</p> <code>n_facets</code> <code>int</code> <p>Number of facets (edges/faces) in the layer.</p> <code>n_nodes</code> <code>int</code> <p>Number of nodes in the layer.</p> <code>n_points</code> <code>int</code> <p>Number of points in the layer. Alias for n_nodes.</p> <code>n_vertices</code> <code>int</code> <p>Number of vertices in the layer. Alias for n_nodes.</p> <code>nodes_index</code> <code>Index</code> <p>Index of the nodes DataFrame.</p> <code>points</code> <code>ndarray</code> <p>Alias for vertices</p> <code>points_index</code> <code>Index</code> <p>Index of the points. Alias for nodes_index.</p> <code>vertices</code> <code>ndarray</code> <p>Array of the spatial coordinates of the vertices</p> <code>vertices_df</code> <code>DataFrame</code> <p>DataFrame of the spatial coordinates of the vertices</p> <code>vertices_index</code> <code>Index</code> <p>Index of the vertices. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Layer.edge_index","title":"<code>edge_index</code>  <code>property</code>","text":"<p>Index of the edges. Alias for facets_index.</p>"},{"location":"api/#morphsync.Layer.facets_index","title":"<code>facets_index</code>  <code>property</code>","text":"<p>Index of the facets DataFrame.</p>"},{"location":"api/#morphsync.Layer.facets_positional","title":"<code>facets_positional</code>  <code>property</code>","text":"<p>Array of the facets in positional indexing, such that 0 corresponds to the first node in its current node index ordering</p>"},{"location":"api/#morphsync.Layer.layer_type","title":"<code>layer_type</code>  <code>property</code>","text":"<p>String identifier of the layer type (e.g., 'mesh', 'points', 'graph').</p>"},{"location":"api/#morphsync.Layer.n_facets","title":"<code>n_facets</code>  <code>property</code>","text":"<p>Number of facets (edges/faces) in the layer.</p>"},{"location":"api/#morphsync.Layer.n_nodes","title":"<code>n_nodes</code>  <code>property</code>","text":"<p>Number of nodes in the layer.</p>"},{"location":"api/#morphsync.Layer.n_points","title":"<code>n_points</code>  <code>property</code>","text":"<p>Number of points in the layer. Alias for n_nodes.</p>"},{"location":"api/#morphsync.Layer.n_vertices","title":"<code>n_vertices</code>  <code>property</code>","text":"<p>Number of vertices in the layer. Alias for n_nodes.</p>"},{"location":"api/#morphsync.Layer.nodes_index","title":"<code>nodes_index</code>  <code>property</code>","text":"<p>Index of the nodes DataFrame.</p>"},{"location":"api/#morphsync.Layer.points","title":"<code>points</code>  <code>property</code>","text":"<p>Alias for vertices</p>"},{"location":"api/#morphsync.Layer.points_index","title":"<code>points_index</code>  <code>property</code>","text":"<p>Index of the points. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Layer.vertices","title":"<code>vertices</code>  <code>property</code>","text":"<p>Array of the spatial coordinates of the vertices</p>"},{"location":"api/#morphsync.Layer.vertices_df","title":"<code>vertices_df</code>  <code>property</code>","text":"<p>DataFrame of the spatial coordinates of the vertices</p>"},{"location":"api/#morphsync.Layer.vertices_index","title":"<code>vertices_index</code>  <code>property</code>","text":"<p>Index of the vertices. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Layer.get_params","title":"<code>get_params()</code>","text":"<p>Get the parameters used to initialize this layer.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing layer initialization parameters.</p>"},{"location":"api/#morphsync.Layer.mask_by_node_index","title":"<code>mask_by_node_index(new_index, new_nodes=None)</code>","text":"<p>Create a new layer containing only the specified nodes and their facets.</p> <p>Parameters:</p> Name Type Description Default <code>new_index</code> <code>Union[ndarray, Index, Series]</code> <p>Index of nodes to keep in the new layer.</p> required <code>new_nodes</code> <code>Optional[DataFrame]</code> <p>Pre-filtered nodes DataFrame. If None, nodes will be filtered automatically based on new_index.</p> <code>None</code> <p>Returns:</p> Type Description <p>A new layer instance containing only the specified nodes and facets that reference those nodes.</p> Notes <p>Only facets that reference exclusively the nodes in new_index are kept.</p>"},{"location":"api/#morphsync.Layer.mask_nodes","title":"<code>mask_nodes(mask)</code>","text":"<p>Mask the nodes DataFrame and return a new layer with the corresponding nodes and facets.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>A boolean mask array to filter the nodes DataFrame. This masking is applied in positional indexing (i.e. order, not key matters).</p> required <p>Returns:</p> Type Description <p>A new layer with the masked nodes and corresponding facets.</p> Notes <p>When masking by nodes, only relationships that reference exclusively the remaining nodes are kept.</p>"},{"location":"api/#morphsync.Layer.query_nodes","title":"<code>query_nodes(query_str)</code>","text":"<p>Query the nodes DataFrame and return a new layer with the corresponding nodes and facets.</p> <p>Parameters:</p> Name Type Description Default <code>query_str</code> <code>str</code> <p>A query string to pass to <code>pd.DataFrame.query</code> on the nodes DataFrame.</p> required <p>Returns:</p> Type Description <p>A new layer with the queried nodes and corresponding facets.</p> Notes <p>When masking by nodes, only relationships that reference exclusively the remaining nodes are kept.</p>"},{"location":"api/#morphsync.Table","title":"<code>morphsync.Table</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Methods:</p> Name Description <code>__repr__</code> <p>Return a string representation of the Table.</p> <code>get_params</code> <p>Get the parameters used to initialize this layer.</p> <code>mask_by_node_index</code> <p>Create a new layer containing only the specified nodes and their facets.</p> <code>mask_nodes</code> <p>Mask the nodes DataFrame and return a new layer with the</p> <code>query_nodes</code> <p>Query the nodes DataFrame and return a new layer with the</p> <p>Attributes:</p> Name Type Description <code>edge_index</code> <code>Index</code> <p>Index of the edges. Alias for facets_index.</p> <code>facets_index</code> <code>Index</code> <p>Index of the facets DataFrame.</p> <code>facets_positional</code> <code>ndarray</code> <p>Array of the facets in positional indexing, such that 0 corresponds to the</p> <code>layer_type</code> <code>str</code> <p>String identifier of the layer type (e.g., 'mesh', 'points', 'graph').</p> <code>n_facets</code> <code>int</code> <p>Number of facets (edges/faces) in the layer.</p> <code>n_nodes</code> <code>int</code> <p>Number of nodes in the layer.</p> <code>n_points</code> <code>int</code> <p>Number of points in the layer. Alias for n_nodes.</p> <code>n_vertices</code> <code>int</code> <p>Number of vertices in the layer. Alias for n_nodes.</p> <code>nodes_index</code> <code>Index</code> <p>Index of the nodes DataFrame.</p> <code>points</code> <code>ndarray</code> <p>Alias for vertices</p> <code>points_index</code> <code>Index</code> <p>Index of the points. Alias for nodes_index.</p> <code>table</code> <code>DataFrame</code> <p>Access the table data as a DataFrame. Alias for nodes.</p> <code>vertices</code> <code>ndarray</code> <p>Array of the spatial coordinates of the vertices</p> <code>vertices_df</code> <code>DataFrame</code> <p>DataFrame of the spatial coordinates of the vertices</p> <code>vertices_index</code> <code>Index</code> <p>Index of the vertices. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Table.edge_index","title":"<code>edge_index</code>  <code>property</code>","text":"<p>Index of the edges. Alias for facets_index.</p>"},{"location":"api/#morphsync.Table.facets_index","title":"<code>facets_index</code>  <code>property</code>","text":"<p>Index of the facets DataFrame.</p>"},{"location":"api/#morphsync.Table.facets_positional","title":"<code>facets_positional</code>  <code>property</code>","text":"<p>Array of the facets in positional indexing, such that 0 corresponds to the first node in its current node index ordering</p>"},{"location":"api/#morphsync.Table.layer_type","title":"<code>layer_type</code>  <code>property</code>","text":"<p>String identifier of the layer type (e.g., 'mesh', 'points', 'graph').</p>"},{"location":"api/#morphsync.Table.n_facets","title":"<code>n_facets</code>  <code>property</code>","text":"<p>Number of facets (edges/faces) in the layer.</p>"},{"location":"api/#morphsync.Table.n_nodes","title":"<code>n_nodes</code>  <code>property</code>","text":"<p>Number of nodes in the layer.</p>"},{"location":"api/#morphsync.Table.n_points","title":"<code>n_points</code>  <code>property</code>","text":"<p>Number of points in the layer. Alias for n_nodes.</p>"},{"location":"api/#morphsync.Table.n_vertices","title":"<code>n_vertices</code>  <code>property</code>","text":"<p>Number of vertices in the layer. Alias for n_nodes.</p>"},{"location":"api/#morphsync.Table.nodes_index","title":"<code>nodes_index</code>  <code>property</code>","text":"<p>Index of the nodes DataFrame.</p>"},{"location":"api/#morphsync.Table.points","title":"<code>points</code>  <code>property</code>","text":"<p>Alias for vertices</p>"},{"location":"api/#morphsync.Table.points_index","title":"<code>points_index</code>  <code>property</code>","text":"<p>Index of the points. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Table.table","title":"<code>table</code>  <code>property</code>","text":"<p>Access the table data as a DataFrame. Alias for nodes.</p>"},{"location":"api/#morphsync.Table.vertices","title":"<code>vertices</code>  <code>property</code>","text":"<p>Array of the spatial coordinates of the vertices</p>"},{"location":"api/#morphsync.Table.vertices_df","title":"<code>vertices_df</code>  <code>property</code>","text":"<p>DataFrame of the spatial coordinates of the vertices</p>"},{"location":"api/#morphsync.Table.vertices_index","title":"<code>vertices_index</code>  <code>property</code>","text":"<p>Index of the vertices. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Table.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Table.</p>"},{"location":"api/#morphsync.Table.get_params","title":"<code>get_params()</code>","text":"<p>Get the parameters used to initialize this layer.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing layer initialization parameters.</p>"},{"location":"api/#morphsync.Table.mask_by_node_index","title":"<code>mask_by_node_index(new_index, new_nodes=None)</code>","text":"<p>Create a new layer containing only the specified nodes and their facets.</p> <p>Parameters:</p> Name Type Description Default <code>new_index</code> <code>Union[ndarray, Index, Series]</code> <p>Index of nodes to keep in the new layer.</p> required <code>new_nodes</code> <code>Optional[DataFrame]</code> <p>Pre-filtered nodes DataFrame. If None, nodes will be filtered automatically based on new_index.</p> <code>None</code> <p>Returns:</p> Type Description <p>A new layer instance containing only the specified nodes and facets that reference those nodes.</p> Notes <p>Only facets that reference exclusively the nodes in new_index are kept.</p>"},{"location":"api/#morphsync.Table.mask_nodes","title":"<code>mask_nodes(mask)</code>","text":"<p>Mask the nodes DataFrame and return a new layer with the corresponding nodes and facets.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>A boolean mask array to filter the nodes DataFrame. This masking is applied in positional indexing (i.e. order, not key matters).</p> required <p>Returns:</p> Type Description <p>A new layer with the masked nodes and corresponding facets.</p> Notes <p>When masking by nodes, only relationships that reference exclusively the remaining nodes are kept.</p>"},{"location":"api/#morphsync.Table.query_nodes","title":"<code>query_nodes(query_str)</code>","text":"<p>Query the nodes DataFrame and return a new layer with the corresponding nodes and facets.</p> <p>Parameters:</p> Name Type Description Default <code>query_str</code> <code>str</code> <p>A query string to pass to <code>pd.DataFrame.query</code> on the nodes DataFrame.</p> required <p>Returns:</p> Type Description <p>A new layer with the queried nodes and corresponding facets.</p> Notes <p>When masking by nodes, only relationships that reference exclusively the remaining nodes are kept.</p>"},{"location":"api/#morphsync.Points","title":"<code>morphsync.Points</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Methods:</p> Name Description <code>__repr__</code> <p>Return a string representation of the Points.</p> <code>get_params</code> <p>Get the parameters used to initialize this layer.</p> <code>mask_by_node_index</code> <p>Create a new layer containing only the specified nodes and their facets.</p> <code>mask_nodes</code> <p>Mask the nodes DataFrame and return a new layer with the</p> <code>query_nodes</code> <p>Query the nodes DataFrame and return a new layer with the</p> <p>Attributes:</p> Name Type Description <code>edge_index</code> <code>Index</code> <p>Index of the edges. Alias for facets_index.</p> <code>facets_index</code> <code>Index</code> <p>Index of the facets DataFrame.</p> <code>facets_positional</code> <code>ndarray</code> <p>Array of the facets in positional indexing, such that 0 corresponds to the</p> <code>index</code> <code>Index</code> <p>Index of the points. Alias for nodes.index.</p> <code>is_spatially_valid</code> <code>bool</code> <p>Check if the points have valid spatial structure.</p> <code>layer_type</code> <code>str</code> <p>String identifier of the layer type (e.g., 'mesh', 'points', 'graph').</p> <code>n_facets</code> <code>int</code> <p>Number of facets (edges/faces) in the layer.</p> <code>n_nodes</code> <code>int</code> <p>Number of nodes in the layer.</p> <code>n_points</code> <code>int</code> <p>Number of points in the layer. Alias for n_nodes.</p> <code>n_vertices</code> <code>int</code> <p>Number of vertices in the layer. Alias for n_nodes.</p> <code>nodes_index</code> <code>Index</code> <p>Index of the nodes DataFrame.</p> <code>points</code> <code>ndarray</code> <p>Alias for vertices</p> <code>points_index</code> <code>Index</code> <p>Index of the points. Alias for nodes_index.</p> <code>vertices</code> <code>ndarray</code> <p>Array of the spatial coordinates of the vertices</p> <code>vertices_df</code> <code>DataFrame</code> <p>DataFrame of the spatial coordinates of the vertices</p> <code>vertices_index</code> <code>Index</code> <p>Index of the vertices. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Points.edge_index","title":"<code>edge_index</code>  <code>property</code>","text":"<p>Index of the edges. Alias for facets_index.</p>"},{"location":"api/#morphsync.Points.facets_index","title":"<code>facets_index</code>  <code>property</code>","text":"<p>Index of the facets DataFrame.</p>"},{"location":"api/#morphsync.Points.facets_positional","title":"<code>facets_positional</code>  <code>property</code>","text":"<p>Array of the facets in positional indexing, such that 0 corresponds to the first node in its current node index ordering</p>"},{"location":"api/#morphsync.Points.index","title":"<code>index</code>  <code>property</code>","text":"<p>Index of the points. Alias for nodes.index.</p>"},{"location":"api/#morphsync.Points.is_spatially_valid","title":"<code>is_spatially_valid</code>  <code>property</code>","text":"<p>Check if the points have valid spatial structure.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if points are 3D and non-empty.</p>"},{"location":"api/#morphsync.Points.layer_type","title":"<code>layer_type</code>  <code>property</code>","text":"<p>String identifier of the layer type (e.g., 'mesh', 'points', 'graph').</p>"},{"location":"api/#morphsync.Points.n_facets","title":"<code>n_facets</code>  <code>property</code>","text":"<p>Number of facets (edges/faces) in the layer.</p>"},{"location":"api/#morphsync.Points.n_nodes","title":"<code>n_nodes</code>  <code>property</code>","text":"<p>Number of nodes in the layer.</p>"},{"location":"api/#morphsync.Points.n_points","title":"<code>n_points</code>  <code>property</code>","text":"<p>Number of points in the layer. Alias for n_nodes.</p>"},{"location":"api/#morphsync.Points.n_vertices","title":"<code>n_vertices</code>  <code>property</code>","text":"<p>Number of vertices in the layer. Alias for n_nodes.</p>"},{"location":"api/#morphsync.Points.nodes_index","title":"<code>nodes_index</code>  <code>property</code>","text":"<p>Index of the nodes DataFrame.</p>"},{"location":"api/#morphsync.Points.points","title":"<code>points</code>  <code>property</code>","text":"<p>Alias for vertices</p>"},{"location":"api/#morphsync.Points.points_index","title":"<code>points_index</code>  <code>property</code>","text":"<p>Index of the points. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Points.vertices","title":"<code>vertices</code>  <code>property</code>","text":"<p>Array of the spatial coordinates of the vertices</p>"},{"location":"api/#morphsync.Points.vertices_df","title":"<code>vertices_df</code>  <code>property</code>","text":"<p>DataFrame of the spatial coordinates of the vertices</p>"},{"location":"api/#morphsync.Points.vertices_index","title":"<code>vertices_index</code>  <code>property</code>","text":"<p>Index of the vertices. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Points.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Points.</p>"},{"location":"api/#morphsync.Points.get_params","title":"<code>get_params()</code>","text":"<p>Get the parameters used to initialize this layer.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing layer initialization parameters.</p>"},{"location":"api/#morphsync.Points.mask_by_node_index","title":"<code>mask_by_node_index(new_index, new_nodes=None)</code>","text":"<p>Create a new layer containing only the specified nodes and their facets.</p> <p>Parameters:</p> Name Type Description Default <code>new_index</code> <code>Union[ndarray, Index, Series]</code> <p>Index of nodes to keep in the new layer.</p> required <code>new_nodes</code> <code>Optional[DataFrame]</code> <p>Pre-filtered nodes DataFrame. If None, nodes will be filtered automatically based on new_index.</p> <code>None</code> <p>Returns:</p> Type Description <p>A new layer instance containing only the specified nodes and facets that reference those nodes.</p> Notes <p>Only facets that reference exclusively the nodes in new_index are kept.</p>"},{"location":"api/#morphsync.Points.mask_nodes","title":"<code>mask_nodes(mask)</code>","text":"<p>Mask the nodes DataFrame and return a new layer with the corresponding nodes and facets.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>A boolean mask array to filter the nodes DataFrame. This masking is applied in positional indexing (i.e. order, not key matters).</p> required <p>Returns:</p> Type Description <p>A new layer with the masked nodes and corresponding facets.</p> Notes <p>When masking by nodes, only relationships that reference exclusively the remaining nodes are kept.</p>"},{"location":"api/#morphsync.Points.query_nodes","title":"<code>query_nodes(query_str)</code>","text":"<p>Query the nodes DataFrame and return a new layer with the corresponding nodes and facets.</p> <p>Parameters:</p> Name Type Description Default <code>query_str</code> <code>str</code> <p>A query string to pass to <code>pd.DataFrame.query</code> on the nodes DataFrame.</p> required <p>Returns:</p> Type Description <p>A new layer with the queried nodes and corresponding facets.</p> Notes <p>When masking by nodes, only relationships that reference exclusively the remaining nodes are kept.</p>"},{"location":"api/#morphsync.Graph","title":"<code>morphsync.Graph</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Methods:</p> Name Description <code>__repr__</code> <p>Return a string representation of the Graph.</p> <code>get_params</code> <p>Get the parameters used to initialize this layer.</p> <code>mask_by_node_index</code> <p>Create a new layer containing only the specified nodes and their facets.</p> <code>mask_nodes</code> <p>Mask the nodes DataFrame and return a new layer with the</p> <code>query_nodes</code> <p>Query the nodes DataFrame and return a new layer with the</p> <code>to_adjacency</code> <p>Convert the graph to an adjacency matrix.</p> <p>Attributes:</p> Name Type Description <code>edge_index</code> <code>Index</code> <p>Index of the edges. Alias for facets_index.</p> <code>edges</code> <code>ndarray</code> <p>Edges as a numpy array of shape (n_edges, 2).</p> <code>edges_df</code> <code>DataFrame</code> <p>Edges as a DataFrame containing node indices.</p> <code>edges_positional</code> <code>ndarray</code> <p>Edges in positional indexing.</p> <code>facets_index</code> <code>Index</code> <p>Index of the facets DataFrame.</p> <code>facets_positional</code> <code>ndarray</code> <p>Array of the facets in positional indexing, such that 0 corresponds to the</p> <code>is_spatially_valid</code> <code>bool</code> <p>Check if the graph has valid spatial structure.</p> <code>layer_type</code> <code>str</code> <p>String identifier of the layer type (e.g., 'mesh', 'points', 'graph').</p> <code>n_edges</code> <code>int</code> <p>Number of edges in the graph.</p> <code>n_facets</code> <code>int</code> <p>Number of facets (edges/faces) in the layer.</p> <code>n_nodes</code> <code>int</code> <p>Number of nodes in the layer.</p> <code>n_points</code> <code>int</code> <p>Number of points in the layer. Alias for n_nodes.</p> <code>n_vertices</code> <code>int</code> <p>Number of vertices in the layer. Alias for n_nodes.</p> <code>nodes_index</code> <code>Index</code> <p>Index of the nodes DataFrame.</p> <code>points</code> <code>ndarray</code> <p>Alias for vertices</p> <code>points_index</code> <code>Index</code> <p>Index of the points. Alias for nodes_index.</p> <code>vertices</code> <code>ndarray</code> <p>Array of the spatial coordinates of the vertices</p> <code>vertices_df</code> <code>DataFrame</code> <p>DataFrame of the spatial coordinates of the vertices</p> <code>vertices_index</code> <code>Index</code> <p>Index of the vertices. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Graph.edge_index","title":"<code>edge_index</code>  <code>property</code>","text":"<p>Index of the edges. Alias for facets_index.</p>"},{"location":"api/#morphsync.Graph.edges","title":"<code>edges</code>  <code>property</code>","text":"<p>Edges as a numpy array of shape (n_edges, 2).</p>"},{"location":"api/#morphsync.Graph.edges_df","title":"<code>edges_df</code>  <code>property</code>","text":"<p>Edges as a DataFrame containing node indices.</p>"},{"location":"api/#morphsync.Graph.edges_positional","title":"<code>edges_positional</code>  <code>property</code>","text":"<p>Edges in positional indexing.</p>"},{"location":"api/#morphsync.Graph.facets_index","title":"<code>facets_index</code>  <code>property</code>","text":"<p>Index of the facets DataFrame.</p>"},{"location":"api/#morphsync.Graph.facets_positional","title":"<code>facets_positional</code>  <code>property</code>","text":"<p>Array of the facets in positional indexing, such that 0 corresponds to the first node in its current node index ordering</p>"},{"location":"api/#morphsync.Graph.is_spatially_valid","title":"<code>is_spatially_valid</code>  <code>property</code>","text":"<p>Check if the graph has valid spatial structure.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if vertices are 3D and both vertices and edges are non-empty.</p>"},{"location":"api/#morphsync.Graph.layer_type","title":"<code>layer_type</code>  <code>property</code>","text":"<p>String identifier of the layer type (e.g., 'mesh', 'points', 'graph').</p>"},{"location":"api/#morphsync.Graph.n_edges","title":"<code>n_edges</code>  <code>property</code>","text":"<p>Number of edges in the graph.</p>"},{"location":"api/#morphsync.Graph.n_facets","title":"<code>n_facets</code>  <code>property</code>","text":"<p>Number of facets (edges/faces) in the layer.</p>"},{"location":"api/#morphsync.Graph.n_nodes","title":"<code>n_nodes</code>  <code>property</code>","text":"<p>Number of nodes in the layer.</p>"},{"location":"api/#morphsync.Graph.n_points","title":"<code>n_points</code>  <code>property</code>","text":"<p>Number of points in the layer. Alias for n_nodes.</p>"},{"location":"api/#morphsync.Graph.n_vertices","title":"<code>n_vertices</code>  <code>property</code>","text":"<p>Number of vertices in the layer. Alias for n_nodes.</p>"},{"location":"api/#morphsync.Graph.nodes_index","title":"<code>nodes_index</code>  <code>property</code>","text":"<p>Index of the nodes DataFrame.</p>"},{"location":"api/#morphsync.Graph.points","title":"<code>points</code>  <code>property</code>","text":"<p>Alias for vertices</p>"},{"location":"api/#morphsync.Graph.points_index","title":"<code>points_index</code>  <code>property</code>","text":"<p>Index of the points. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Graph.vertices","title":"<code>vertices</code>  <code>property</code>","text":"<p>Array of the spatial coordinates of the vertices</p>"},{"location":"api/#morphsync.Graph.vertices_df","title":"<code>vertices_df</code>  <code>property</code>","text":"<p>DataFrame of the spatial coordinates of the vertices</p>"},{"location":"api/#morphsync.Graph.vertices_index","title":"<code>vertices_index</code>  <code>property</code>","text":"<p>Index of the vertices. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Graph.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Graph.</p>"},{"location":"api/#morphsync.Graph.get_params","title":"<code>get_params()</code>","text":"<p>Get the parameters used to initialize this layer.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing layer initialization parameters.</p>"},{"location":"api/#morphsync.Graph.mask_by_node_index","title":"<code>mask_by_node_index(new_index, new_nodes=None)</code>","text":"<p>Create a new layer containing only the specified nodes and their facets.</p> <p>Parameters:</p> Name Type Description Default <code>new_index</code> <code>Union[ndarray, Index, Series]</code> <p>Index of nodes to keep in the new layer.</p> required <code>new_nodes</code> <code>Optional[DataFrame]</code> <p>Pre-filtered nodes DataFrame. If None, nodes will be filtered automatically based on new_index.</p> <code>None</code> <p>Returns:</p> Type Description <p>A new layer instance containing only the specified nodes and facets that reference those nodes.</p> Notes <p>Only facets that reference exclusively the nodes in new_index are kept.</p>"},{"location":"api/#morphsync.Graph.mask_nodes","title":"<code>mask_nodes(mask)</code>","text":"<p>Mask the nodes DataFrame and return a new layer with the corresponding nodes and facets.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>A boolean mask array to filter the nodes DataFrame. This masking is applied in positional indexing (i.e. order, not key matters).</p> required <p>Returns:</p> Type Description <p>A new layer with the masked nodes and corresponding facets.</p> Notes <p>When masking by nodes, only relationships that reference exclusively the remaining nodes are kept.</p>"},{"location":"api/#morphsync.Graph.query_nodes","title":"<code>query_nodes(query_str)</code>","text":"<p>Query the nodes DataFrame and return a new layer with the corresponding nodes and facets.</p> <p>Parameters:</p> Name Type Description Default <code>query_str</code> <code>str</code> <p>A query string to pass to <code>pd.DataFrame.query</code> on the nodes DataFrame.</p> required <p>Returns:</p> Type Description <p>A new layer with the queried nodes and corresponding facets.</p> Notes <p>When masking by nodes, only relationships that reference exclusively the remaining nodes are kept.</p>"},{"location":"api/#morphsync.Graph.to_adjacency","title":"<code>to_adjacency(return_as='csr', weights=None, symmetrize=False)</code>","text":"<p>Convert the graph to an adjacency matrix.</p> <p>Parameters:</p> Name Type Description Default <code>return_as</code> <code>str</code> <p>Format to return the adjacency matrix. Currently only \"csr\" is supported.</p> <code>'csr'</code> <code>weights</code> <code>Optional[str]</code> <p>Column name in facets to use as edge weights. If None, uses unit weights.</p> <code>None</code> <code>symmetrize</code> <code>bool</code> <p>If True, add reverse edges to make the graph symmetric.</p> <code>False</code> <p>Returns:</p> Type Description <p>Sparse adjacency matrix of shape (n_nodes, n_nodes).</p>"},{"location":"api/#morphsync.Mesh","title":"<code>morphsync.Mesh</code>","text":"<p>               Bases: <code>Layer</code></p> <p>Methods:</p> Name Description <code>__repr__</code> <p>Return a string representation of the Mesh.</p> <code>from_dict</code> <p>Create a Mesh from a dictionary containing vertices and faces.</p> <code>get_params</code> <p>Get the parameters used to initialize this layer.</p> <code>mask_by_node_index</code> <p>Create a new layer containing only the specified nodes and their facets.</p> <code>mask_nodes</code> <p>Mask the nodes DataFrame and return a new layer with the</p> <code>query_nodes</code> <p>Query the nodes DataFrame and return a new layer with the</p> <p>Attributes:</p> Name Type Description <code>edge_index</code> <code>Index</code> <p>Index of the edges. Alias for facets_index.</p> <code>faces</code> <code>ndarray</code> <p>Faces as a numpy array in positional indexing.</p> <code>facets_index</code> <code>Index</code> <p>Index of the facets DataFrame.</p> <code>facets_positional</code> <code>ndarray</code> <p>Array of the facets in positional indexing, such that 0 corresponds to the</p> <code>is_spatially_valid</code> <code>bool</code> <p>Check if the mesh has valid spatial structure.</p> <code>layer_type</code> <code>str</code> <p>String identifier of the layer type (e.g., 'mesh', 'points', 'graph').</p> <code>mesh</code> <code>tuple[ndarray, ndarray]</code> <p>Get the mesh as a tuple of (vertices, faces).</p> <code>n_facets</code> <code>int</code> <p>Number of facets (edges/faces) in the layer.</p> <code>n_nodes</code> <code>int</code> <p>Number of nodes in the layer.</p> <code>n_points</code> <code>int</code> <p>Number of points in the layer. Alias for n_nodes.</p> <code>n_vertices</code> <code>int</code> <p>Number of vertices in the layer. Alias for n_nodes.</p> <code>nodes_index</code> <code>Index</code> <p>Index of the nodes DataFrame.</p> <code>points</code> <code>ndarray</code> <p>Alias for vertices</p> <code>points_index</code> <code>Index</code> <p>Index of the points. Alias for nodes_index.</p> <code>vertices</code> <code>ndarray</code> <p>Array of the spatial coordinates of the vertices</p> <code>vertices_df</code> <code>DataFrame</code> <p>DataFrame of the spatial coordinates of the vertices</p> <code>vertices_index</code> <code>Index</code> <p>Index of the vertices. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Mesh.edge_index","title":"<code>edge_index</code>  <code>property</code>","text":"<p>Index of the edges. Alias for facets_index.</p>"},{"location":"api/#morphsync.Mesh.faces","title":"<code>faces</code>  <code>property</code>","text":"<p>Faces as a numpy array in positional indexing.</p>"},{"location":"api/#morphsync.Mesh.facets_index","title":"<code>facets_index</code>  <code>property</code>","text":"<p>Index of the facets DataFrame.</p>"},{"location":"api/#morphsync.Mesh.facets_positional","title":"<code>facets_positional</code>  <code>property</code>","text":"<p>Array of the facets in positional indexing, such that 0 corresponds to the first node in its current node index ordering</p>"},{"location":"api/#morphsync.Mesh.is_spatially_valid","title":"<code>is_spatially_valid</code>  <code>property</code>","text":"<p>Check if the mesh has valid spatial structure.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if vertices are 3D, faces are triangular, and both are non-empty.</p>"},{"location":"api/#morphsync.Mesh.layer_type","title":"<code>layer_type</code>  <code>property</code>","text":"<p>String identifier of the layer type (e.g., 'mesh', 'points', 'graph').</p>"},{"location":"api/#morphsync.Mesh.mesh","title":"<code>mesh</code>  <code>property</code>","text":"<p>Get the mesh as a tuple of (vertices, faces).</p>"},{"location":"api/#morphsync.Mesh.n_facets","title":"<code>n_facets</code>  <code>property</code>","text":"<p>Number of facets (edges/faces) in the layer.</p>"},{"location":"api/#morphsync.Mesh.n_nodes","title":"<code>n_nodes</code>  <code>property</code>","text":"<p>Number of nodes in the layer.</p>"},{"location":"api/#morphsync.Mesh.n_points","title":"<code>n_points</code>  <code>property</code>","text":"<p>Number of points in the layer. Alias for n_nodes.</p>"},{"location":"api/#morphsync.Mesh.n_vertices","title":"<code>n_vertices</code>  <code>property</code>","text":"<p>Number of vertices in the layer. Alias for n_nodes.</p>"},{"location":"api/#morphsync.Mesh.nodes_index","title":"<code>nodes_index</code>  <code>property</code>","text":"<p>Index of the nodes DataFrame.</p>"},{"location":"api/#morphsync.Mesh.points","title":"<code>points</code>  <code>property</code>","text":"<p>Alias for vertices</p>"},{"location":"api/#morphsync.Mesh.points_index","title":"<code>points_index</code>  <code>property</code>","text":"<p>Index of the points. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Mesh.vertices","title":"<code>vertices</code>  <code>property</code>","text":"<p>Array of the spatial coordinates of the vertices</p>"},{"location":"api/#morphsync.Mesh.vertices_df","title":"<code>vertices_df</code>  <code>property</code>","text":"<p>DataFrame of the spatial coordinates of the vertices</p>"},{"location":"api/#morphsync.Mesh.vertices_index","title":"<code>vertices_index</code>  <code>property</code>","text":"<p>Index of the vertices. Alias for nodes_index.</p>"},{"location":"api/#morphsync.Mesh.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the Mesh.</p>"},{"location":"api/#morphsync.Mesh.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a Mesh from a dictionary containing vertices and faces.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary with 'vertices' and 'faces' keys.</p> required <p>Returns:</p> Type Description <code>Mesh</code> <p>A new Mesh instance.</p>"},{"location":"api/#morphsync.Mesh.get_params","title":"<code>get_params()</code>","text":"<p>Get the parameters used to initialize this layer.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary containing layer initialization parameters.</p>"},{"location":"api/#morphsync.Mesh.mask_by_node_index","title":"<code>mask_by_node_index(new_index, new_nodes=None)</code>","text":"<p>Create a new layer containing only the specified nodes and their facets.</p> <p>Parameters:</p> Name Type Description Default <code>new_index</code> <code>Union[ndarray, Index, Series]</code> <p>Index of nodes to keep in the new layer.</p> required <code>new_nodes</code> <code>Optional[DataFrame]</code> <p>Pre-filtered nodes DataFrame. If None, nodes will be filtered automatically based on new_index.</p> <code>None</code> <p>Returns:</p> Type Description <p>A new layer instance containing only the specified nodes and facets that reference those nodes.</p> Notes <p>Only facets that reference exclusively the nodes in new_index are kept.</p>"},{"location":"api/#morphsync.Mesh.mask_nodes","title":"<code>mask_nodes(mask)</code>","text":"<p>Mask the nodes DataFrame and return a new layer with the corresponding nodes and facets.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>A boolean mask array to filter the nodes DataFrame. This masking is applied in positional indexing (i.e. order, not key matters).</p> required <p>Returns:</p> Type Description <p>A new layer with the masked nodes and corresponding facets.</p> Notes <p>When masking by nodes, only relationships that reference exclusively the remaining nodes are kept.</p>"},{"location":"api/#morphsync.Mesh.query_nodes","title":"<code>query_nodes(query_str)</code>","text":"<p>Query the nodes DataFrame and return a new layer with the corresponding nodes and facets.</p> <p>Parameters:</p> Name Type Description Default <code>query_str</code> <code>str</code> <p>A query string to pass to <code>pd.DataFrame.query</code> on the nodes DataFrame.</p> required <p>Returns:</p> Type Description <p>A new layer with the queried nodes and corresponding facets.</p> Notes <p>When masking by nodes, only relationships that reference exclusively the remaining nodes are kept.</p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#coming-soon","title":"Coming soon","text":""},{"location":"examples/examples/","title":"Examples","text":""},{"location":"examples/examples/#coming-soon","title":"Coming soon","text":""},{"location":"examples/microns_example/","title":"Microns example","text":"<p>Note: while these packages are not required for the use of MorphLink, they are used here to demonstrate the functionality of the package with real data and integration with multiple other packages. This tutorial requires:</p> <ul> <li><code>CAVEclient</code>,</li> <li><code>skeletor</code>,</li> <li><code>pcg_skel</code>,</li> <li><code>pyvista</code>,</li> </ul> <p>all of which are available on PyPI.</p> <pre><code>from caveclient import CAVEclient\n\nclient = CAVEclient(\"minnie65_public\")\n</code></pre> <p>Create a <code>MorphLink</code> instance. This is the object we'll use for keeping track of different features and representations of morphology.</p> <pre><code>from morphlink import MorphLink\n\nmorphology = MorphLink()\n</code></pre> <p>We'll start by getting the morphology of a single neuron as a mesh.</p> <pre><code>root_id = 864691135361314119\n\ncv = client.info.segmentation_cloudvolume(progress=False)\nmesh = cv.mesh.get(\n    root_id, deduplicate_chunk_boundaries=False, remove_duplicate_vertices=False\n)[root_id]\n</code></pre> <p>We can add this to our morphology representation using the <code>add_mesh</code> method.</p> <pre><code>morphology.add_mesh(mesh, \"mesh\")\nmorphology.layers\n</code></pre> layer layer_type name mesh Mesh(vertices=2652062, faces=5293626) Mesh <p>Next, we can add the nucleus location for this neuron. This is a new type of layer, in this case just a single point.</p> <pre><code>nuc_info = client.materialize.query_table(\n    \"nucleus_detection_v0\",\n    filter_equal_dict={\"pt_root_id\": root_id},\n    split_positions=True,\n    desired_resolution=[1, 1, 1],\n)\nnuc_loc = nuc_info[[\"pt_position_x\", \"pt_position_y\", \"pt_position_z\"]].values.squeeze()\nnuc_loc\n</code></pre> <pre>\n<code>array([725760., 491456., 853080.])</code>\n</pre> <pre><code>morphology.add_points(nuc_loc, \"nucleus\")\n</code></pre> <pre><code>morphology.layers\n</code></pre> layer layer_type name mesh Mesh(vertices=2652062, faces=5293626) Mesh nucleus Points(points=(1, 3)) Points <pre><code>polydatas = morphology.to_pyvista()\n\nimport pyvista as pv\n\n\ndef set_camera(plotter, zoom=10):\n    plotter.camera.focal_point = nuc_loc\n    plotter.camera_position = \"zy\"\n    plotter.camera.up = (0, -1, 0)\n    plotter.camera.focal_point = nuc_loc\n    plotter.camera.zoom(zoom)\n\n\nWINDOW_SIZE = [2400, 1500]\npv.set_jupyter_backend(\"static\")\nplotter = pv.Plotter(window_size=WINDOW_SIZE)\nplotter.add_mesh(polydatas[\"mesh\"], color=\"lightgrey\", opacity=0.5)\nplotter.add_points(\n    polydatas[\"nucleus\"], color=\"red\", point_size=60, render_points_as_spheres=True\n)\n\nset_camera(plotter, zoom=5)\n\nplotter.show()\n</code></pre> <p>Now, let's link these objects together. The simplest mapping is to annotate the nucleus location on the mesh as the closest point. Under the hood, the <code>add_link</code> method will find the closest point on the mesh and save that mapping.</p> <pre><code>morphology.add_link(\"nucleus\", \"mesh\", mapping=\"closest\")\n\nmorphology.links\n</code></pre> link link_origin source target nucleus mesh nucleus     mesh 0        0  1220064 closest <p>We can retreive the mapping between the nucleus and the mesh using the <code>get_link</code> method. This returns a DataFrame with the mapping as its two columns.</p> <pre><code>morphology.get_link(\"nucleus\", \"mesh\")\n</code></pre> nucleus mesh 0 0 1220064 <p>We can also ask for the specific mapping for a point in our nucleus layer. Since we only have one point in this layer, we just get one item back from the mapping, denoting the closest point on the mesh.</p> <pre><code>mesh_nuc_index = morphology.get_mapping(\"nucleus\", \"mesh\")\n\nmesh_nuc_index\n</code></pre> <pre>\n<code>Index([1220064], dtype='int64', name='mesh')</code>\n</pre> <p>Similarly, we can add another layer that consists of many points - in this case, synapses onto this neuron.</p> <pre><code>post_synapses = client.materialize.query_table(\n    \"synapses_pni_2\",\n    filter_equal_dict={\"post_pt_root_id\": root_id},\n    split_positions=True,\n    desired_resolution=[1, 1, 1],\n)\npost_synapses.set_index(\"id\", inplace=True)\n\nspatial_cols = [\"ctr_pt_position_x\", \"ctr_pt_position_y\", \"ctr_pt_position_z\"]\npost_synapse_locs = post_synapses[spatial_cols]\npost_synapse_info = post_synapses.drop(columns=spatial_cols)\n</code></pre> <p>Specifically, we'll specify the synapse locations using a <code>points</code> layer, which allows future methods to do space-aware operations on this layer.</p> <pre><code>morphology.add_points(\n    post_synapse_locs,\n    \"post_synapses\",\n)\n</code></pre> <p>Additionally, we'll add the rest of the synapse info using the <code>add_table</code> method, which will add a space-independent table of data.</p> <pre><code>morphology.add_table(\n    post_synapse_info,\n    \"post_synapse_info\",\n)\n</code></pre> <p>Finally, to make sure that the above information about the synapses gets mapped to the synapse locations, we can use the <code>add_link</code> method again.</p> <pre><code>morphology.add_link(\n    \"post_synapse_info\", \"post_synapses\", mapping=\"index\", reciprocal=True\n)\n</code></pre> <pre><code>plotter = pv.Plotter(window_size=WINDOW_SIZE)\nplotter.add_mesh(polydatas[\"mesh\"], color=\"lightgrey\")\nplotter.add_points(\n    morphology.post_synapses.to_pyvista(),\n    color=\"blue\",\n    point_size=10,\n    render_points_as_spheres=True,\n)\n\nset_camera(plotter, zoom=5)\n\nplotter.show()\n</code></pre> <p>Let's add another link, here again finding the closest point on the mesh for each synapse.</p> <pre><code>morphology.add_link(\"post_synapses\", \"mesh\")\n\nmorphology.links\n</code></pre> link link_origin source target nucleus mesh nucleus     mesh 0        0  1220064 closest post_synapse_info post_synapses post_synapse_info  post_synapses 0      ... index post_synapses post_synapse_info post_synapse_info  post_synapses 0      ... index mesh post_synapses     mesh 0         1873158... closest <p>It can be helpful to visualize these mappings. Conceptually, it is as if we have created edges from our points in the synapse layer to the corresponding closest points in the mesh layer. We include a <code>get_link_as_layer</code> method to visualize these edges (note that this does not actually add a new layer to the <code>MorphLink</code> object).</p> <pre><code>plotter = pv.Plotter(window_size=WINDOW_SIZE)\nplotter.add_mesh(polydatas[\"mesh\"], color=\"lightgrey\", opacity=0.1)\nplotter.add_points(\n    morphology.post_synapses.to_pyvista(),\n    color=\"blue\",\n    point_size=10,\n    render_points_as_spheres=True,\n)\nplotter.add_mesh(\n    morphology.get_link_as_layer(\"post_synapses\", \"mesh\").to_pyvista(),\n    color=\"black\",\n    show_vertices=True,\n    line_width=3,\n    point_size=5,\n)\n\nset_camera(plotter, zoom=80)\n\nplotter.show()\n</code></pre> <p>Now, we can do something a bit more interesting. Let's skeletonize the mesh, using the nucleus as the source points for the skeletonization.</p> <p>Note: requires <code>skeletor</code> package to be installed.</p> <pre><code>import time\n\nfrom skeletor.skeletonize import by_wavefront\n\ncurrtime = time.time()\n\nout = by_wavefront(mesh, origins=mesh_nuc_index.to_list(), progress=True)\nprint(f\"{time.time() - currtime:.3f} seconds elapsed.\")\n</code></pre> <pre>\n<code>Skeletonizing:   0%|          | 0/2652062 [00:00&lt;?, ?it/s]</code>\n</pre> <pre>\n<code>24.459 seconds elapsed.\n</code>\n</pre> <p>This skeletonization process stores the mapping between mesh vertices and the new, collapsed vertices from the skeletonization. First, let's add the skeleton to our morphology representations.</p> <pre><code>morphology.add_graph(out, \"skeleton\")\n</code></pre> <pre><code>plotter = pv.Plotter(window_size=WINDOW_SIZE)\nplotter.add_mesh(morphology.mesh.to_pyvista(), color=\"lightgrey\", opacity=0.3)\nplotter.add_mesh(\n    morphology.post_synapses.to_pyvista(),\n    color=\"blue\",\n    point_size=10,\n    render_points_as_spheres=True,\n)\nplotter.add_mesh(morphology.skeleton.to_pyvista(), color=\"red\", line_width=2)\nset_camera(plotter, zoom=5)\nplotter.show()\n</code></pre> <p>Then, we can add the mapping between the mesh and the skeleton. This mapping is stored in the <code>mesh_map</code> attribute of the skeletonization output.</p> <pre><code>morphology.add_link(\"mesh\", \"skeleton\", mapping=out.mesh_map)\n</code></pre> <pre><code>morphology.links\n</code></pre> link link_origin source target nucleus mesh nucleus     mesh 0        0  1220064 closest post_synapse_info post_synapses post_synapse_info  post_synapses 0      ... index post_synapses post_synapse_info post_synapse_info  post_synapses 0      ... index mesh post_synapses     mesh 0         1873158... closest mesh skeleton mesh  skeleton 0              0   ... specified <p>Now, we might also be interested in where synapses are located along the skeleton. Even though the skeletonization map doesn't have a direct mapping between the mesh and the synapses, we can first map synapses to their points on the mesh, and then map those mesh points to their points on the skeleton.</p> <p>Fortunately, this kind of transitive mapping is handled automatically by MorphLink under the hood. Internally, there is a graph that denotes relationships between different layers, and the <code>link_path</code> method can be used to find the path from a source layer to a target layer (if one exists).</p> <p>Many times, this will just be a direct link.</p> <pre><code>morphology.get_link_path(\"post_synapses\", \"mesh\")\n</code></pre> <pre>\n<code>['post_synapses', 'mesh']</code>\n</pre> <p>But as in the case of the synapses and the skeleton, it will find the path that involves mapping synapses to the mesh, and then the mesh to the skeleton.</p> <pre><code>morphology.get_link_path(\"post_synapses\", \"skeleton\")\n</code></pre> <pre>\n<code>['post_synapses', 'mesh', 'skeleton']</code>\n</pre> <pre><code>synapse_skeleton_ids = morphology.get_mapping(\"post_synapses\", \"skeleton\")\nsynapse_skeleton_ids\n</code></pre> <pre>\n<code>Index([124839,  64175, 121215, 115029,  54276,  10115,  46720, 114390, 103022,\n        53731,\n       ...\n        97907, 133495,  48629,  46546,  27888, 116864,  71817,  67137, 116485,\n       116624],\n      dtype='int64', name='skeleton', length=3216)</code>\n</pre> <pre><code>skeleton_synapse_points = morphology.skeleton.nodes.iloc[synapse_skeleton_ids]\n\nplotter = pv.Plotter(window_size=WINDOW_SIZE)\nplotter.add_mesh(morphology.skeleton.to_pyvista(), color=\"red\", line_width=2)\nplotter.add_points(\n    skeleton_synapse_points.values,\n    color=\"blue\",\n    point_size=5,\n    render_points_as_spheres=True,\n)\nset_camera(plotter, zoom=5)\nplotter.show()\n</code></pre> <pre><code>import numpy as np\n\nedgelist = client.chunkedgraph.level2_chunk_graph(root_id)\nedgelist = np.array(edgelist)\n</code></pre> <pre><code>level2_ids = np.unique(edgelist)\n\nl2_data = client.l2cache.get_l2data(\n    level2_ids,\n    attributes=[\"area_nm2\", \"max_dt_nm\", \"mean_dt_nm\", \"size_nm3\", \"rep_coord_nm\"],\n)\n</code></pre> <pre><code>import pandas as pd\n\nl2_nodes = pd.DataFrame(l2_data).T\nl2_nodes.index = l2_nodes.index.astype(int)\nl2_nodes[\"x\"] = l2_nodes[\"rep_coord_nm\"].apply(lambda x: x[0])\nl2_nodes[\"y\"] = l2_nodes[\"rep_coord_nm\"].apply(lambda x: x[1])\nl2_nodes[\"z\"] = l2_nodes[\"rep_coord_nm\"].apply(lambda x: x[2])\nl2_node_locs = l2_nodes[[\"x\", \"y\", \"z\"]]\nl2_node_info = l2_nodes.drop(columns=[\"x\", \"y\", \"z\", \"rep_coord_nm\"])\n</code></pre> <pre><code>morphology.add_graph((l2_node_locs, edgelist), \"l2_graph\")\nmorphology.add_table(l2_node_info, \"l2_info\")\nmorphology.add_link(\"l2_info\", \"l2_graph\", mapping=\"index\", reciprocal=True)\nmorphology.layers\n</code></pre> layer layer_type name mesh Mesh(vertices=2652062, faces=5293626) Mesh nucleus Points(points=(1, 3)) Points post_synapses Points(points=(3216, 3)) Points post_synapse_info Table(rows=3216) Table skeleton Graph(nodes=(155446, 3), edges=(154842, 2)) Graph l2_graph Graph(nodes=(11131, 3), edges=(12473, 2)) Graph l2_info Table(rows=11131) Table <p>Skeletonizing the level2 graph can also provide a quick way to get a skeleton, albeit at the loss of some spatial resolution.</p> <pre><code>from pcg_skel import pcg_skeleton_direct\n</code></pre> <p>Note that the edges were supplied as named index pairs, not on positional node indices.</p> <pre><code>morphology.l2_graph.edges\n</code></pre> <pre>\n<code>array([[153486945027096730, 153487013746573379],\n       [153486945027096730, 153557313771274442],\n       [153487013746573379, 153557382490751099],\n       ...,\n       [170095617920467521, 170165986664644757],\n       [170165917945168013, 170165986664644757],\n       [170165986664644757, 170166055384121514]])</code>\n</pre> <p>But <code>edges_positional</code> will return the edges with positional node indices.</p> <pre><code>morphology.l2_graph.edges_positional\n</code></pre> <pre>\n<code>array([[    0,     1],\n       [    0,     4],\n       [    1,     5],\n       ...,\n       [11127, 11129],\n       [11128, 11129],\n       [11129, 11130]])</code>\n</pre> <pre><code>pcg_skeleton = pcg_skeleton_direct(\n    morphology.l2_graph.vertices,\n    morphology.l2_graph.edges_positional,\n    collapse_soma=True,\n    root_point=np.squeeze(morphology.nucleus.vertices),\n)\n</code></pre> <pre>\n<code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 11130/11130 [00:00&lt;00:00, 56442.19it/s]\n</code>\n</pre> <pre><code>morphology.add_graph(pcg_skeleton, \"pcg_skeleton\")\n</code></pre> <pre><code>plotter = pv.Plotter(window_size=WINDOW_SIZE)\n# pv.set_jupyter_backend('client')\n# plotter = pv.Plotter()\nplotter.add_mesh(morphology.mesh.to_pyvista(), color=\"lightgrey\", opacity=0.3)\nplotter.add_mesh(morphology.l2_graph.to_pyvista(), color=\"lime\", line_width=3)\nplotter.add_mesh(morphology.pcg_skeleton.to_pyvista(), color=\"darkred\", line_width=3)\n\nset_camera(plotter, zoom=15)\n\nplotter.show()\n</code></pre> <p>Again, let's add some links, including the one created by the skeletonization process. The rest will just be again based on nearest point mappings, for now.</p> <pre><code>morphology.add_link(\"l2_graph\", \"pcg_skeleton\", mapping=pcg_skeleton.mesh_to_skel_map)\nmorphology.add_link(\"nucleus\", \"pcg_skeleton\", mapping=\"closest\")\n\n# these ones in particular are not perfect and could be refined with CAVEclient calls,\n# but let's see how it does\nmorphology.add_link(\"mesh\", \"pcg_skeleton\", mapping=\"closest\")\nmorphology.add_link(\"l2_graph\", \"mesh\", mapping=\"closest\")\n</code></pre> <pre><code>morphology.links\n</code></pre> link link_origin source target nucleus mesh nucleus     mesh 0        0  1220064 closest post_synapse_info post_synapses post_synapse_info  post_synapses 0      ... index post_synapses post_synapse_info post_synapse_info  post_synapses 0      ... index mesh post_synapses     mesh 0         1873158... closest mesh skeleton mesh  skeleton 0              0   ... specified l2_info l2_graph l2_info            l2_graph ... index l2_graph l2_info l2_info            l2_graph ... index pcg_skeleton l2_graph  pcg_skeleton 0     ... specified nucleus pcg_skeleton nucleus  pcg_skeleton 0        0          5535 closest mesh pcg_skeleton mesh  pcg_skeleton 0              ... closest l2_graph mesh l2_graph     mesh 0      1534... closest <p>A common operation one might want to do on a neuron is to mask out the axon, or extract just the axon, etc. <code>morphlink</code> aims to be agnostic to how you want to compute something like \"where is the axon on this neuron\", and is only here to help you keep track of how that labeling implicitly applies to other parts of a morphology.</p> <p>As a concrete example, computing this kind of split of axon/dendrite can be done using the skeleton and its synapses.</p> <pre><code>pre_synapses = client.materialize.query_table(\n    \"synapses_pni_2\",\n    filter_equal_dict={\"pre_pt_root_id\": root_id},\n    split_positions=True,\n    desired_resolution=[1, 1, 1],\n)\npre_synapses = pre_synapses.query(\"pre_pt_root_id != post_pt_root_id\")\npre_synapses.set_index(\"id\", inplace=True)\n\nmorphology.add_points(\n    pre_synapses[spatial_cols],\n    \"pre_synapses\",\n)\nmorphology.add_table(pre_synapses.drop(columns=spatial_cols), \"pre_synapse_info\")\nmorphology.add_link(\"pre_synapse_info\", \"pre_synapses\", mapping=\"index\")\n</code></pre> <pre><code>morphology.add_link(\"pre_synapses\", \"mesh\")\n</code></pre> <pre><code>morphology.links\n</code></pre> link link_origin source target nucleus mesh nucleus     mesh 0        0  1220064 closest post_synapse_info post_synapses post_synapse_info  post_synapses 0      ... index post_synapses post_synapse_info post_synapse_info  post_synapses 0      ... index mesh post_synapses     mesh 0         1873158... closest mesh skeleton mesh  skeleton 0              0   ... specified l2_info l2_graph l2_info            l2_graph ... index l2_graph l2_info l2_info            l2_graph ... index pcg_skeleton l2_graph  pcg_skeleton 0     ... specified nucleus pcg_skeleton nucleus  pcg_skeleton 0        0          5535 closest mesh pcg_skeleton mesh  pcg_skeleton 0              ... closest l2_graph mesh l2_graph     mesh 0      1534... closest pre_synapse_info pre_synapses pre_synapse_info  pre_synapses 0         ... index pre_synapses mesh pre_synapses     mesh 0       221097100  ... closest <pre><code>morphology.get_mapping(\"post_synapses\", \"pcg_skeleton\")\n</code></pre> <pre>\n<code>Index([4277, 5535, 4105, 4047, 1973,  501, 1654, 3932, 3586, 1904,\n       ...\n       3299, 4559, 1752, 1664, 1073, 4041, 2532, 2292, 4034, 4093],\n      dtype='int64', name='pcg_skeleton', length=3216)</code>\n</pre> <pre><code>morphology.get_mapping(\"pre_synapses\", \"pcg_skeleton\")\n</code></pre> <pre>\n<code>Index([5216, 3623, 2283,  377, 1480, 5475,  421, 4343, 5395, 4625,\n       ...\n        578, 4340, 1179,  553, 3149, 4246,  103, 4228, 4341, 4789],\n      dtype='int64', name='pcg_skeleton', length=657)</code>\n</pre> <pre><code>from scipy.sparse.linalg import eigsh\nfrom scipy.sparse import diags_array\n\nadj = morphology.pcg_skeleton.to_adjacency()\nadj = adj + adj.T\ndegrees = adj.sum(axis=0)\ndegree_matrix = diags_array([degrees], offsets=[0], shape=adj.shape)\nlaplacian = degree_matrix - adj\n\neigvals, eigvecs = eigsh(laplacian, k=5, sigma=-1e-12)\n</code></pre> <pre><code>post_inds = morphology.get_mapping(\"post_synapses\", \"pcg_skeleton\")\npre_inds = morphology.get_mapping(\"pre_synapses\", \"pcg_skeleton\")\n\nX_post = eigvecs[post_inds]\nX_pre = eigvecs[pre_inds]\n\ny_post = np.zeros(len(post_inds))\ny_pre = np.ones(len(pre_inds))\n\nX = np.concatenate([X_post, X_pre])\ny = np.concatenate([y_post, y_pre])\n\nfrom sklearn.discriminant_analysis import LinearDiscriminantAnalysis\n\ncols = np.arange(1, eigvecs.shape[1])\nlda = LinearDiscriminantAnalysis()\nlda.fit(X[:, cols], y)\n\npred_labels = lda.predict(eigvecs[:, cols])\npcg_skeleton_info = pd.DataFrame(\n    index=morphology.pcg_skeleton.nodes.index, data=pred_labels, columns=[\"pred_labels\"]\n)\n</code></pre> <pre><code>morphology.add_table(pcg_skeleton_info, \"pcg_skeleton_info\")\nmorphology.add_link(\n    \"pcg_skeleton_info\", \"pcg_skeleton\", mapping=\"index\", reciprocal=True\n)\n</code></pre> <pre><code>plotter = pv.Plotter(window_size=WINDOW_SIZE)\nplotter.add_mesh(morphology.mesh.to_pyvista(), color=\"lightgrey\", opacity=0.3)\nplotter.add_mesh(\n    morphology.pcg_skeleton.to_pyvista(),\n    color=\"darkred\",\n    scalars=morphology.pcg_skeleton_info.nodes[\"pred_labels\"].values,\n    cmap=\"coolwarm\",\n    line_width=3,\n    show_scalar_bar=False,\n)\nplotter.add_points(\n    morphology.post_synapses.to_pyvista(),\n    color=\"blue\",\n    point_size=5,\n    render_points_as_spheres=True,\n)\nplotter.add_points(\n    morphology.pre_synapses.to_pyvista(),\n    color=\"red\",\n    point_size=5,\n    render_points_as_spheres=True,\n)\nset_camera(plotter, zoom=4)\nplotter.show()\n</code></pre> <p>Now, the more interesting part: independent of whatever algorithm we chose for doing this split for us, let's see how to mask the rest of the neuron and all of its layers based on this split. Even though the split will be defined in terms of the <code>pcg_skeleton_info</code> layer, the masking will be applied to all layers, and will leverage the direct and transitive mappings we've set up so far.</p> <p>To do this, we'll use the <code>query_nodes</code> method, and specify the layer we want to mask.</p> <pre><code>morphology.drop_layer(\"skeleton\")  # dropping because no path to pcg_skeleton\nmasked_morphology = morphology.query_nodes(\"pred_labels == 0\", \"pcg_skeleton_info\")\nmasked_morphology\n</code></pre> <pre>\n<code>MorphLink(layers=['mesh', 'nucleus', 'post_synapses', 'post_synapse_info', 'l2_graph', 'l2_info', 'pcg_skeleton', 'pre_synapses', 'pre_synapse_info', 'pcg_skeleton_info'], links=[])</code>\n</pre> <pre><code>plotter = pv.Plotter(window_size=WINDOW_SIZE, shape=(1, 2))\n\nplotter.subplot(0, 0)\nplotter.add_mesh(morphology.mesh.to_pyvista(), color=\"lightgrey\", opacity=0.3)\nplotter.add_mesh(\n    morphology.pcg_skeleton.to_pyvista(),\n    scalars=morphology.pcg_skeleton_info.nodes[\"pred_labels\"],\n    cmap=\"coolwarm\",\n    line_width=2,\n    show_scalar_bar=False,\n)\nplotter.add_points(\n    morphology.pre_synapses.to_pyvista(),\n    color=\"red\",\n    point_size=5,\n    render_points_as_spheres=True,\n)\nplotter.add_points(\n    morphology.post_synapses.to_pyvista(),\n    color=\"blue\",\n    point_size=5,\n    render_points_as_spheres=True,\n)\n\nplotter.subplot(0, 1)\nplotter.add_mesh(masked_morphology.mesh.to_pyvista(), color=\"lightgrey\", opacity=0.3)\nplotter.add_mesh(\n    masked_morphology.pcg_skeleton.to_pyvista(),\n    scalars=masked_morphology.pcg_skeleton_info.nodes[\"pred_labels\"],\n    cmap=\"coolwarm\",\n    line_width=2,\n    show_scalar_bar=False,\n)\nplotter.add_points(\n    masked_morphology.pre_synapses.to_pyvista(),\n    color=\"red\",\n    point_size=5,\n    render_points_as_spheres=True,\n)\nplotter.add_points(\n    masked_morphology.post_synapses.to_pyvista(),\n    color=\"blue\",\n    point_size=5,\n    render_points_as_spheres=True,\n)\n\nplotter.link_views()\nset_camera(plotter, zoom=2)\nplotter.show()\n</code></pre> <p>As a sanity check, note that now very few presynaptic sites are left in our morphology, as expected since we masked out the axon.</p> <pre><code>masked_morphology.pre_synapses.nodes.shape[0]\n</code></pre> <pre>\n<code>10</code>\n</pre> <p>We can also see how the volume of our morphology changed after masking.</p> <pre><code>pre_volume = morphology.l2_info.nodes[\"size_nm3\"].sum()\npost_volume = masked_morphology.l2_info.nodes[\"size_nm3\"].sum()\nprint(pre_volume)\nprint(post_volume)\nprint(post_volume / pre_volume)\n</code></pre> <pre>\n<code>2162887339520\n1769880386560\n0.8182952270425614\n</code>\n</pre>"},{"location":"examples/microns_example/#initialization","title":"Initialization","text":"<p>Start a CAVEclient</p>"},{"location":"examples/microns_example/#adding-a-mesh","title":"Adding a mesh","text":""},{"location":"examples/microns_example/#adding-point-annotations","title":"Adding point annotations","text":""},{"location":"examples/microns_example/#adding-a-skeleton","title":"Adding a skeleton","text":""},{"location":"examples/microns_example/#more-complex-mappings","title":"More complex mappings","text":""},{"location":"examples/microns_example/#working-with-a-level2-graph","title":"Working with a level2 graph","text":""},{"location":"examples/microns_example/#masking-and-filtering","title":"Masking and filtering","text":""}]}